package Seco::Jumpstart;

use 5.006;
use strict;
use warnings 'all';
use Seco::Jumpstart::Utils qw/:all/ ;
use Socket;
use Net::Netmask;

our $VERSION = '1.0.2';

## stuff
sub new {
    my ($class, $cfg) = @_;
    bless { 'cfg' => $cfg }, $class;
}

sub disable_daemons {
    system("chroot /mnt chkconfig haldaemon off");
    system("chroot /mnt chkconfig smartd off");
}

sub get_mounted_on {
    my $dir = shift;
    my @df = `cd /mnt/$dir;df -k .`;
    my $mounted = (split ' ', $df[-1])[-1];
    $mounted =~ s{^/mnt}{};
    return $mounted eq "" ? "/" : $mounted;
}

sub check_fslayout {
    my $self = shift;
    my $cfg = $self->{cfg};
    my $yst_layout = $cfg->get('enforce_yst_layout');

    if ($yst_layout ne "yes") {
        return;
    }
    return;
    
    if (get_mounted_on("/export/crawlspace") eq "/") {
        figlet("Wrong fs-layout");
        set_status("ERROR: fs-layout - /export/crawlspace mounted on /");
        system("/bin/sh");
    }
}

sub prepare {
    my $self = shift;
    my $cfg = $self->{cfg};
    my $hostname = $cfg->get('hostname');

    mkdir "/sys";
    system("mount -t sysfs /sys /sys");
    system("hostname $hostname");
    $self->fix_mtab;
}

sub fix_mtab {
    system("cp /proc/mounts /etc/mtab");
}

sub etch_resolv_conf {
    my $self = shift;
    my $cfg = $self->{cfg};
    my $hostname = $cfg->get('hostname');
    my $cmd = qq(echo "GET /jumpstart/etch_resolv_conf.cgi?hostname=$hostname").
      qq(|nc boothost 9999 > /etc/resolv.conf);
    system($cmd);
    system(qq(cp /etc/resolv.conf /mnt/etc/resolv.conf));
    return 1;
}

sub should_i_jump {
    my $self = shift;
    my $cfg = $self->{cfg};
    my $hostname = $cfg->get('hostname');
    my $cmd = qq(echo "GET /jumpstart/should_i_jump.cgi?hostname=$hostname").
      qq(| nc boothost 9999);
    
    my $answer = `$cmd`;
    chomp($answer);
    
    my $ok = 0;
    if ($answer =~ /^YES/) {
	$ok = 1;
    }
    print "* The admin node said: $answer\n";
    
    return if $ok;
    sleep(180);
    exit(1);
}

sub copy_mtab {
    open my $fh, "</etc/mtab" or die "/etc/mtab: $!";
    open my $ofh, ">/mnt/etc/mtab" or die "/mnt/etc/mtab: $!";
    while (<$fh>) {
	next unless m{/mnt};
	s{/mnt/}{/} or s{/mnt}{/}; # for /
	print $ofh $_;
    }
    close $fh;
    close $ofh;
}

sub reboot {
    system("sync;sync;reboot -f");
}

#XXX:(yuting):
# sub run_inetd {
#     system("inetd");
# }

sub update_overrides {
    my $self = shift;
    my $cfg = $self->{cfg};
    my $hostname = $cfg->get('hostname');

    return unless -r "/jumpstart/overrides.txt";
    open my $fh, "</jumpstart/overrides.txt" or do {
	warn "ERROR: /jumpstart/overrides.txt: $!\n";
	return;
    };

    my @overrides = <$fh>;
    chomp(@overrides);

    close $fh;

    my $args = join("&", @overrides);
    my $cmd = "echo 'GET /jumpstart/overrides.cgi?hostname=$hostname&$args'|nc boothost 9999";
    System($cmd);
}

sub fix_modprobe {
    #XXX:(yuting): no need fix_modprobe now.
    #XXX:(yuting): udevd will help us to maint
    #XXX:(yuting): modprobe.conf
    return ;
    unless (file_has("/etc/modprobe.conf", "alias net-pf-10")) {
	open my $fh, ">>/etc/modprobe.conf" or return;
	print $fh "\nalias net-pf-10 off\n";
	close $fh;
    }
}

sub set_utc {
	System("ln -sfn /usr/share/zoneinfo/UTC /mnt/etc/localtime");
	open my $tzfile, ">/mnt/etc/timezone";
	print $tzfile "UTC\n";
	close $tzfile;
}

sub make_symlinks {
    my $self = shift;
    my $symlinks = $self->{cfg}->{disklayout}->{symlinks};
    return undef unless ref $symlinks eq 'ARRAY';

    for my $pair (@$symlinks) {
        next unless my ($src, $dest) = @$pair;
        if (($src  !~ /^\/[a-z0-9]+/i) or
            ($dest !~ /^\/[a-z0-9]+/i)) {
            warn "ERROR: not symlinking $src -> $dest: should be abs paths\n";
            return undef;
        }

        system("mkdir", "-p", "/mnt/$dest");
        system("mkdir", "-p", "/mnt/$src");
        rmdir "/mnt/$src";
        symlink $dest, "/mnt/$src" or warn "ERROR: symlink $dest, $src: $!\n";
    }
}


sub serials {
    my $self = shift;
    my $cfg = $self->{cfg};
    my $console_speed = $cfg->get("serial_speed");
    my $console_port = $cfg->get("serial_port");
    
    #XXX:(yuting): just return;
    return;

    my @serial_ports = map { /^(\d+):/ and $1 or 0 }
	grep { /uart/ && ! /:unknown/ }
	split("\n", read_file("/proc/tty/driver/serial"));

    my @inittab = grep { ! /agetty/ }
      split("\n", read_file("/mnt/etc/inittab"));

    for (@serial_ports) {
        my $speed = ($_ == $console_port) ?
            $console_speed :
            9600;

        push @inittab,
            "c$_:2345:respawn:/sbin/agetty ttyS$_ $speed vt100-nav";
    }

    write_file("/mnt/etc/inittab", join("\n", @inittab) .
	"\n\n#Generated by jumpstart\n");
}

sub random_fixes {
    system("chroot /mnt chkconfig --del rhnsd");
    system("cp /tmp/zapsector.status /mnt/root/zapsector.status")
        if(-f "/tmp/zapsector.status");
    #XXX:(yuting): TODO set_asia_shanghai() 
    #set_utc();
}

sub resolv_conf {
    system("cp /mnt/etc/resolv.conf-gem /mnt/etc/resolv.conf");
}

sub set_hostname {
    my $self = shift;
    my $cfg = $self->{cfg};
    my $hostname = $cfg->get('hostname');
    #$hostname =~ s/\.inktomi(?:search)?\.com$//;
    $hostname =~ s/\.rangestack\.com$//;
    System("hostname $hostname");
    System("chroot /mnt hostname $hostname");
}

sub fix_motd {
    my $self = shift;

    # Fix the annoying managed-by: pain -> pain -> DURINGJUMP
    system("cp /mnt/etc/resolv.conf /etc/resolv.conf");
    my $cfg = $self->{cfg};
    my $hostname = $cfg->get('hostname');
    my $boothost = $cfg->get('boothost');

    my $boothostname = get_hostname($boothost);
    $boothostname =~ s/\.inktomi.*$//;
    chomp($boothostname);

    my @motd;
    open MOTD, "/mnt/etc/motd" or die "/mnt/etc/motd!: $!";
    while (<MOTD>) {
	if (/^managed-by:/) {
	    $_ = "managed-by: cluster-admin via pain -> " .
	      "$boothostname -> $hostname\n";
	}
	push @motd, $_;
    }
    close MOTD;

    open MOTD, ">", "/mnt/etc/motd" or die "/mnt/etc/motd!: $!";
    print MOTD $_ for @motd;
    close MOTD;
}

sub generate_repo_conf {
    my $self = shift;

    return $self->generate_yum_conf if(os() eq 'redhat');
}

sub generate_yum_conf {
    my $self = shift;

    #XXX:(yuting): just return for test;
    #XXX:(yuting): use template_dir .
    #XXX:(yuting): 精细化 yum repo 的配置. 以后再完善.
    return ;

    my $cfg = $self->{cfg};
    my $hostname = $cfg->get('hostname');
    my $cmd = qq(echo "GET /jumpstart/get-yum-server.cgi?hostname=$hostname" | nc boothost 9999);
    my $yumrepo = `$cmd`;
    chomp $yumrepo;
    crapout("couldn't get yum repository. check get-yum-server.cgi output") unless $yumrepo =~ /\w+/;
    $yumrepo .= ":9999";
    my $repotext; 
    if(my $updatelevel = $cfg->get('rhel4_update_level')) { 
        $repotext = <<EOF;
[base]
name=Red Hat Linux \$releasever - \$basearch - Base
baseurl=http://$yumrepo/yum/RHEL/\$releasever.\$basearch/$updatelevel/RedHat/RPMS

[updates]
name=Red Hat Linux \$releasever - \$basearch Updates
baseurl=http://$yumrepo/yum/RHEL/\$releasever.\$basearch/$updatelevel/updates

[yst]
name=YST \$releasever - \$basearch
baseurl=http://$yumrepo/yum/RHEL/\$releasever.\$basearch/yst

[yst-noarch]
name=YST \$releasever - noarch
baseurl=http://$yumrepo/yum/RHEL/\$releasever.noarch/yst
EOF

    } else {
        $repotext = <<EOF;
[base]
name=Red Hat Linux \$releasever - \$basearch - Base
baseurl=http://$yumrepo/yum/RPMS.\$releasever-\$basearch/

[updates]
name=Red Hat Linux \$releasever - \$basearch Updates
baseurl=http://$yumrepo/yum/updates.\$releasever-\$basearch/

[yst]
name=YST \$releasever - \$basearch
baseurl=http://$yumrepo/yum/yst.\$releasever-\$basearch/

EOF
   }
    open my $yumconf, ">/mnt/etc/yum.conf";
    print $yumconf <<EOF;
# GENERATED BY JUMPSTART
[main]
cachedir=/var/cache/yum
debuglevel=2
logfile=/var/log/yum.log
pkgpolicy=newest
distroverpkg=redhat-release
tolerant=1
exactarch=1
obsoletes=1


# PUT YOUR REPOS HERE OR IN separate files named file.repo
# in /etc/yum.repos.d
$repotext

EOF
    
    close $yumconf;
    return 1;
}

sub installpkg {
    my $self = shift;
    my $pkg = shift;
    
    my $cfg = $self->{cfg};
    my $package_installer = $cfg->get('package_installer');
    my $cmd;
    if ($package_installer ne "yum") {
	$cmd = "apt-get update;apt-get -q -y install $pkg";
    } else {
	#XXX:(yuting): see output for testing.
	#$cmd = "yum -y -d1 -e1 install $pkg";
	$cmd = "yum -y install $pkg";
    }

    print "\% resolve.conf content \n";
    system("cp /mnt/etc/resolv.conf /tmp/ar.conf");
    print "\% cmd is:[chroot /mnt sh -c $cmd]\n";	
    print "\% Installing $pkg\n";

    system("chroot /mnt sh -c '$cmd'");
    
    if ($?) {
	print "ERROR: executing $cmd\n";
    }
}

# Load the right kernel
sub install_kernel {
    my $self = shift;
    my $cfg = $self->{cfg};
    $self->installpkg($cfg->{kernel_package});
    
    if ($cfg->get('package_installer') ne 'yum' &&
	$cfg->get('def_fs') eq "xfs") {
	system("chroot /mnt apt-get update;" .
	       "chroot /mnt apt-get -q -y install xfsprogs");
    }
}

sub ntpdate {
    my $self = shift;
    
    my $cfg = $self->{cfg};
    my $ip = $cfg->get('ip');
    my $server = $cfg->get("boothost");
    System("ntpdate -b $server");
    system("date");
    System("hwclock --systohc");
}

sub extra_modules {
    my $self = shift;
    my $cfg = $self->{cfg};
    my $hostname = $cfg->get("hostname");

    return unless $hostname =~ /^nyn/;

    chomp(my $arch = `uname -i`);
    chomp(my $release = `uname -r`);

    # your gross kludge here
}

sub image_root {
    my $self = shift;
    my $cfg = $self->{cfg};
    
    # $diskimage contains the url to a tarball
    if($cfg->get('diskimage') =~ m#(http://)([^/]+)(/.*)$#) {
	my ($protocol, $boothost, $path) = ( $1, $2, $3 );
	my $fs = $cfg->get('def_fs');
	my $bootdevice;
        
	if($cfg->get('bootdisk')) {
	    my $firstdrive = $cfg->get('bootdisk');
	    $firstdrive .= "p" if $firstdrive =~ /\d$/;
	    $bootdevice = "/dev/" . $firstdrive . "1";
	} else {
	    $bootdevice = $cfg->get('bootdevice');
            my $firstdrive = $bootdevice;
            $firstdrive =~ s/\d+//;
	}
        
	if ($cfg->get('rootonly')) {
	    print("checking existing root image");
	    my $partsize = `fdisk  -u  -s $bootdevice` + 0;
	    if ($partsize < 999000) {
		crapout("ERROR: Existing partition size is $partsize, " .
			"needs to be >= 999000");
	    }
	    print("Existing root partition size is $partsize, good\n");
	    print("copying exising fstab/mdadm by mounting old / read only\n");
	    run_local(qq(/bin/mount -o ro $bootdevice /mnt));
	    run_local(qw(/bin/cp /mnt/etc/fstab /tmp/fstab));
	    run_local(qw(/bin/cp /mnt/etc/mdadm.conf /tmp/mdadm.conf));
	    run_local(qw(/bin/umount /mnt));
	    print("Existing fstab:\n");
	    run_local(qw(/bin/cat /tmp/fstab));
	}
        
	my $uncompress_cmd = "gzip -d";
	if ( $path =~ /bz2$/ ) {
	    $uncompress_cmd = "bzip2 -d";
	}

	# Mount all the filesystems
        if(-f "/tmp/fstab.local") {
            open my $fst, "</tmp/fstab.local";
            my @fstab = <$fst>;
            close $fst;

            for (@fstab) {
                my ($dev, $point, $fstype, $opts) = split;
                next unless $fstype =~ /^ext[23]|xfs$/;
                system("mkdir -p /mnt$point");
                system("mount -t $fstype $dev -o $opts /mnt$point");
                crapout("Couldn't mount $dev: ($?) $!") if $?;
            }
        } else {
            system("mount -t $fs $bootdevice /mnt");
            crapout("Couldn't mount $bootdevice: ($?) $!") if $?;
        }
        
	my $tar_cmd = "(cd /mnt;tar xpSf -)";
	if ($path =~ /cpio/) {
	    $tar_cmd = "(cd /mnt; cpio -i --sparse " .
	      "--make-directories --preserve-modification-time)";
	}
        
	my $primary_iface = $cfg->get('primary_iface');
	my $mtu = $cfg->get('eth0_mtu');
	System("ifconfig $primary_iface mtu $mtu");
	# my $err = System("echo 'GET $path' | nc $boothost 9999 | " .
	#        "$uncompress_cmd | $tar_cmd >/dev/null 2>/dev/null");
	my $err = System("echo 'GET $path' | nc $boothost 9999 | " .
	       "$uncompress_cmd | $tar_cmd ");
        if ($err) {
            print "\nWARNING: couldn't download the os-image from the network. Retrying\n";
            $err = System("echo 'GET $path' | nc $boothost 9999 | " .
	       "$uncompress_cmd | $tar_cmd");
            crapout("downloading the OS image from the network")
               if $err;
        }
    } else {
	crapout('$diskimage not defined in profile');
    }
}

sub mount_newroot {
    my $self = shift;
    my $cfg = $self->{cfg};
    
    print("Mounting /mnt (your new / partition) for read/write\n");
    open my $mtab_fh, ">/mnt/etc/mtab" or die "/etc/mtab: $!";

    open my $fstab_fh, "</tmp/fstab" or die "Failed to open /tmp/fstab: $!";
    while (<$fstab_fh>) {
	chomp;
	next if (/^#/);
	my ($device, $mountpoint, $type, $options, $rest ) = split(' ', $_, 5);
        if ($type eq "nfs") {
            system("mkdir -p /mnt$mountpoint");
        }
	next unless ( $type =~ m/^(ext[23]|xfs)/ );
	if ($mountpoint eq "/") {
	    print $mtab_fh "$device $mountpoint $type rw,$options $rest\n";
	    if ($cfg->is('softwareraid')) { last; } else { next; }
	}
	my $newmount = "/mnt" . $mountpoint;
	system("mkdir -p $newmount");
	run_local( "/bin/mount", "-o", "rw", "-t", $type, $device, $newmount );
	print $mtab_fh "$device $mountpoint $type rw,$options $rest";
    }
    close $mtab_fh;
    
    mkdir "/mnt/sys";
    mkdir "/mnt/proc";
    mkdir "/mnt/dev";
    system("mount -t proc -o nosuid,noexec,nodev proc /mnt/proc");
    system("mount -t sysfs -o nosuid,noexec,nodev sysfs /mnt/sys");
    system("mount -t devtmpfs -o mode=0755,nosuid,strictatime devtmpfs /mnt/dev");
    
    unlink "/mnt/etc/modules.conf" if(-e "/mnt/etc/modules.conf"
                                      and os() eq 'redhat');
    close $fstab_fh;
    
    unless ( -w "/mnt" ) {
	crapout("Mounting /mnt as read-write failed - / is not writable");
    }
    unless (-e "/mnt/etc/passwd") {
	crapout("root filesystem seems to be corrupted\n");
    }

    `cp /tmp/fstab.disk /mnt/etc/fstab` if(-f "/tmp/fstab.disk");
}

sub fix_fstab_labels {
    my $self = shift;
    my $cfg = $self->{cfg};

    open my $fstab_fh, "</tmp/fstab";
    open my $fstab_ofh, ">/tmp/fstab-fix";
    while (<$fstab_fh>) {
	if (/^#/) {
	    print $fstab_ofh $_;
	    next;
	}

	my ($device, $mountpoint, $type, $rest) = split(' ', $_, 4);

	if ($type =~ /^ext/) {
	    $device = "LABEL=" . label_for_mountpoint($mountpoint);
	}
        
	print $fstab_ofh "$device\t$mountpoint\t$type\t$rest";
    }
    close $fstab_fh;
    close $fstab_ofh;
    unlink "/tmp/fstab";
    rename "/tmp/fstab-fix" => "/tmp/fstab";
}

sub fix_fstab_swraid {
    my $self = shift;
    my $cfg = $self->{cfg};
    
    my $fs = $cfg->get('def_fs') || "ext2";
    system("grep -v /export /tmp/fstab | " .
	   "grep -v /local | " .
	   "grep -v /home > " .
	   "/tmp/fstab-fix");
    unlink "/tmp/fstab";
    rename "/tmp/fstab-fix" => "/tmp/fstab";
    
    my $mount_point = $cfg->get('swraid_mountpoint');
    my $label = label_for_mountpoint($mount_point);
    system("echo 'LABEL=$label $mount_point $fs rw,noatime 0 0' >>/tmp/fstab");
    system("mkdir -p /mnt/$mount_point");
    system("mount -t $fs /dev/md0 /mnt/$mount_point");
}

sub create_mdadm {
    my @mdadm = `mdadm -D --scan`;
    open my $mdadm_fh, ">/mnt/etc/mdadm.conf" or return 0;
    print $mdadm_fh "DEVICE partitions\n";
    print $mdadm_fh (join '', @mdadm);
    print $mdadm_fh "MAILADDR tingle2008\@gmail.com\n";
    close $mdadm_fh;
}

sub fix_fstab {
    my $self = shift;
    my $cfg = $self->{cfg};

    if ($cfg->is('softwareraid')) {
	$self->fix_fstab_swraid;
    } else {
	$self->fix_fstab_labels;
    }

    my $home_mount_point = "/home";
    if (file_has( "/tmp/fstab", '\s/home\s' ) ) {
	$home_mount_point = "/adminhome";
	mkdir "/mnt/$home_mount_point";
    }

    if ($cfg->get('nfs_home') =~ m!^/!) {
        open( my $fstab_fh, ">>/tmp/fstab" ) or die "Failed to cat >> /tmp/fstab : $!";
        print $fstab_fh "adminhost:/export/home " . $cfg->get('nfs_home') .
          " nfs rsize=8192,wsize=8192,hard,intr,rw,noatime     0 0\n";
        close $fstab_fh;
    }

    if (lc($cfg->get('nfs_home')) eq "yes") {
        open( my $fstab_fh, ">>/tmp/fstab" ) or die "Failed to cat >> /tmp/fstab : $!";
        print $fstab_fh "adminhost:/export/home $home_mount_point nfs "
          . "rsize=8192,wsize=8192,hard,intr,rw,noatime     0 0\n" ;
        close $fstab_fh;
    }

    #if ($cfg->is('softwareraid')) {
    # if (os() eq "debian") {
    # FIXME: do mdadm on debian
    #figlet("MDADM DEBIAN");
    #run_local(qw(ln -s /etc/init.d/raid2 /mnt/etc/rcS.d/S30raid2));
    #}
    #}
    
    if (os() eq "redhat") {
	system('echo "none /dev/pts devpts  gid=5,mode=620  0 0">>/tmp/fstab');
	system('echo "none /dev/shm tmpfs  defaults  0 0">>/tmp/fstab');
    }
    
    System("cp /tmp/fstab /mnt/etc/fstab");
    System("cksum /tmp/fstab /mnt/etc/fstab");
}

sub fix_etc {
    my $self = shift;
    my $cfg = $self->{cfg};
    
    my $etcdir = $cfg->get('etcdir');
    print("Scanning $etcdir\n");
    my @found = `find $etcdir -type f`;
    chomp(@found);
    
    print("Writing helper script\n");
    my $d = localtime;
    open(PIE, ">>/tmp/perlpie")
      || crapout("Failed to create /tmp/perlpie : $!");
    
    my $domain = "rangestack.com";

    #XXX:(yuting): if $cfg->get() failed return no value
    #XXX:(yuting): network/broadcast is not here.
    my ($hostname, $ip, $boothost, $gateway, $netmask,
     	$network, $broadcast, $motd_tag) = map { $cfg->get($_) }
	qw/hostname ip boothost gateway netmask network broadcast motd_tag/;

    my $ip10 = $ip;
    $ip10 =~ s/\d+/10/;
    
    print PIE <<EOF;
#! /usr/local/bin/perl -pi
 s/{{domain}}/$domain/g;
 s/{{hostname}}/$hostname/g;
 s/{{ip}}/$ip/g;
 s/{{ip10}}/$ip10/g;
 s/{{myip}}/$ip/g;
 s/{{boothost}}/$boothost/g;
 s/{{gateway}}/$gateway/g;
 s/{{netmask}}/$netmask/g;
 s/{{date}}/$d/g;
 s/{{Jump}}/$motd_tag/g;
 s/{{jump}}/$motd_tag/g;
 s/{{profile}}/$motd_tag/g;
 s/{{base}}/$network/g;
 s/{{broadcast}}/$broadcast/g;
EOF
    
    close PIE;
    system("/bin/chmod a+x /tmp/perlpie");
    system("/tmp/perlpie", @found);
    for my $etc (split ' ', $etcdir) {
	system("rsync -a $etc/. /mnt/etc/.");
    }
    
    #XXX:(yuting): hp cciss partition config change.
    open my $part, "</proc/partitions";
    my @pts = <$part>;
    close $part;
    
    my @out = grep { /cciss/ } @pts;
    if(scalar @out > 0) {
	system('perl -pi -e "s/^T1:23/#T1:23/" /mnt/etc/inittab');
    }
    #XXX:(yuting): if not match cciss then nothing happened.

    #XXX:(yuting): rpc fix for some info about  nfs .
#     if (-f '/mnt/etc/redhat-release') {
#         open F, '>>', '/mnt/etc/sysconfig/network';
#         print F <<EOF;
# LOCKD_UDPPORT=2000
# RQUOTAD_PORT=2001
# MOUNTD_PORT=2002
# STATD_PORT=2003
# STATD_OUTGOING_PORT=2004
# EOF
#        close F;
#     }
    
    $self->create_mdadm;
}

sub get_best_ip {
    my $self = shift;
    my $cfg = $self->{cfg};
    my $adminhost = shift;
    print "DEBUG: adminhost from gemstone = $adminhost\n";
    
    my $base = $cfg->{network};
    my $netmask = $cfg->{netmask};
    my $block = Net::Netmask->new($base, $netmask);
    
    my @ips = gethostbyname($adminhost);
    splice(@ips, 0, 4); # discard useless info
    @ips = map { inet_ntoa($_) } @ips;
    my $adminhost_ip;
    for my $ip (@ips) {
        if ($block->match($ip)) {
            # found an ip in our netblock, let's use it
            $adminhost_ip = $ip;
            last;
        }
    }
    $adminhost_ip = $ips[0] unless $adminhost_ip;
    print "DEBUG: best ip = $adminhost_ip\n";

    return $adminhost_ip;
}

sub create_etc_hosts {
    my $self = shift;
    my $adminhostname = shift;
    my $cfg = $self->{cfg};
    
    my $hostname = $cfg->get('hostname');
    my $ip = $cfg->get('ip');
    my $boothost = $cfg->get('boothost');
    my $gateway = $cfg->get('gateway');

    #XXX:(yuting): short-cut @ sina.
    open my $fh, ">/mnt/etc/hosts" or die "/mnt/etc/hosts: $!";
    print $fh <<EOT;
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
$ip         $hostname
$boothost   boothost
$gateway    gateway
EOT
close $fh;
    return ;
    #XXX:(yuting): end here.

    my $adminhost = '';
    $adminhostname ||= `chroot /mnt perl -I/usr/local/lib/perl5/site_perl -MSeco::Gemstone::Range=':all' -le 'print expand_range("^$hostname")'`;
    chomp($adminhostname);
    $adminhost = $self->get_best_ip($adminhostname) if $adminhostname;
    
    my $shortname = $hostname;
    if ($shortname =~ /\.yahoo\.(?:net|com)$/) {
        $shortname =~ s/\.yahoo\.(?:net|com)$//;
    } elsif ($shortname =~ /\.rangestack\.com$/) {
	$shortname =~ s/\.rangestack\.com$//;
    } else {
        $hostname .= ".rangestack.com";
    }
    open my $fh, ">/mnt/etc/hosts" or die "/mnt/etc/hosts: $!";
    print $fh <<EOT;
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
$ip         $shortname $hostname 
EOT
    $adminhost = $boothost unless defined $adminhost;
    if ($boothost eq $adminhost) {
        print $fh "$boothost adminhost.inktomisearch.com boothost adminhost\n";
    } else {
        print $fh "$boothost boothost.inktomisearch.com boothost\n";
        print $fh "$adminhost adminhost.inktomisearch.com adminhost\n";
    }
    print $fh "$gateway gateway\n";
    close $fh;
}

sub get_size {
    my $file = shift;
    my $size = (stat($file))[7];
    return $size;
}

sub fix_resolv_conf {
    my $self = shift;
    my $cfg = $self->{cfg};
    my $boothost = $cfg->get('boothost');
    my $hostname = $cfg->get('hostname');
    # system("echo search rangestack.com > /etc/resolv.conf");
    if ($hostname =~ /^somespacialhost/) {
        system("echo nameserver $boothost >> /etc/resolv.conf");
        system("echo nameserver xx.xx.xx.xx >> /etc/resolv.conf");
        system("echo nameserver xx.xx.xx.xx >> /etc/resolv.conf");
    } else {
	#XXX:(yuting): work @ sina intra
	system("echo nameserver 10.210.12.10 >> /etc/resolv.conf");
    }
    system('cp /etc/resolv.conf /mnt/etc/resolv.conf-gem');
    system("cp /etc/resolv.conf /mnt/etc/resolv.conf");
}

sub clear_resolvconf {
    print "\nClearing out resolv.conf\n";
    system("rm /mnt/etc/resolv.conf");
    system("echo search rangestack.com > /mnt/etc/resolv.conf");
    system("cp /mnt/etc/resolv.conf /etc/resolv.conf");
    print "resolv.conf now has:\n";
    system("cat /etc/resolv.conf");
    print "\n";
}

sub passwd_dnslog {
    #XXX:(yuting): just return;
    return;

    open my $passwd, "</mnt/etc/passwd";
    my @pwd = <$passwd>;
    close $passwd;
    
    my @dnsline = grep { /^dnslog:/ } @pwd;
    if(scalar @dnsline == 0) {
	push @pwd, "dnslog:x:65399:65534:DNS Log User:/var/empty:/bin/false\n";
 	write_file("/mnt/etc/passwd", (join '', @pwd));
    }
}

sub download_gemclient_data {
    my $self = shift;

    System("cd /mnt/export/crawlspace/gemclient; echo 'GET /tftpboot/gemstone-latest.tar.gz' | nc boothost 9999 | tar zSxp");
    return -e "/mnt/export/crawlspace/gemclient/transforms/DEFAULT";
}

sub run_gemclient {
    my ($self, $has_local_data) = @_;
    my $local_arg = $has_local_data ? "-l" : "";
    system("chroot /mnt /usr/local/bin/perl -I/usr/local/lib/perl5/site_perl /usr/local/gemclient/bin/run -f all $local_arg 2>&1");
    
    if ($?) {
	warn "WARNING: gemclient reported an error!\n";
	system("grep gemstone: /etc/motd");
	print "\n\n";
    }
}

sub make_more_cciss_devs {
    my $self = shift;
    my $cfg = $self->{cfg};
    my $p = "/mnt/dev/cciss";
    system "rm -rf $p";
    system "mkdir -p $p";
    for my $maj (0..3) {
	    for my $dsk (0..15) {
		system "mknod $p/c$maj"."d$dsk b ".($maj + 104)." ".($dsk * 16);
		for my $par (1..15) {
			system "mknod $p/c$maj"."d$dsk"."p$par b ".($maj + 104)." ".(($dsk?$dsk:1) * $par);
		}
	    }
    }
}

sub check_redhat {
    my $self = shift;
    return unless -e "/mnt/etc/redhat-release";
    #XXX:(yuting): now we don't need check redhat
    return;

    my $release = read_file("/mnt/etc/redhat-release");
    if ($release =~ /Linux AS release 4/) {
        # Verify that the machine is part of the REDHAT group
        my $motd = read_file("/mnt/etc/motd");
        unless ($motd =~ /groups:.*REDHAT/) {
            chomp(my $arch = `uname -i`);
            my $group = $arch eq "x86_64" ? "RHEL4_64" : "RHEL4_32";
            set_status("ERROR: Not in the $group group");
            print "\n\nERROR: This machine is being jumped as RHEL4, but is not in the gemstone $group group\n";
            print "\n";
            system("/bin/sh");
            die;
        }
    }
}

sub custom_packages {
    my $self = shift;
    my $cfg = $self->{cfg};
    my $install_packages = $cfg->get('install_packages');
    my $after_install_command = $cfg->get('after_install_command');
    my $hostname = $cfg->get('hostname');

    for my $pkg (@$install_packages) {
        $self->installpkg($pkg);
    }

    my $err = System("chroot /mnt sh -c '$after_install_command'");
    if ($err) {
        figlet("Failed to configure");
        set_status("ERROR: $after_install_command failed");
        sleep 60;
        exit(1);
    }

    #XXX:(yuting): no need install ssh keys now.
    #$self->install_ssh_keys;

    $self->fix_resolv_conf();
    # We assume that somehow Seco::Range was installed
    #XXX:(yuting): jump out.
    return;

    my $admin = `chroot /mnt /usr/local/bin/perl -MSeco::Range=:all -le "print expand_range('^$hostname')"`;
    chomp($admin);
    $self->create_etc_hosts($admin);
}

sub install_ssh_keys {
    my $self = shift;
 
    system("rm -f /mnt/etc/ssh/*key*");
    System("echo 'GET /jumpstart/skher.cgi' | nc boothost 9999 | " .
	   "(cd /mnt/etc/ssh/ && tar xf -)");

    unless (-e "/mnt/etc/ssh/ssh_host_rsa_key.pub") {
        print "\n\nERROR: The boothost did not give us our ssh keys.\n";
        print "The usual error for this is reverse DNS is broken,\n";
        print "If that's ok verify boothost:/JumpStart/cgi/skher.cgi\n";
        print "\nExiting this shell will continue the jumpstart process\n";
        system("sh");
    }

}

sub install_etch {
    my $self = shift;
    my $cfg = $self->{cfg};
    
    unlink "/mnt/etc/securetty";

    print "\nInstalling yum.conf\n";
    my $ulevel = $cfg->get('rhel4_update_level');
    system("chroot /mnt wget -O /etc/yum.conf " .
           "http://yum/yum/AS4-i386/configs/yum.conf-AS4-i386-$ulevel");
    print "\nUpdating base system\n";
    system("chroot /mnt yum -e 0 -d 0 -y update");
    
    # print "\nInstalling yinst\n";
    # system("chroot /mnt wget -O /tmp/yinst http://yum/yinst/yinst");
    # system("chroot /mnt ln -s /usr/bin/perl /usr/local/bin/perl");
    # system("chroot /mnt perl /tmp/yinst self-install");
    
    print "\nRegistering with centcom\n";
    $self->installpkg('perl-libwww-perl');
    $self->installpkg('machinereg');
    $self->installpkg('kernel-smp');
    system("chroot /mnt sh -c 'mount /proc; /root/cron/machinereg; " .
           "umount /proc'");
    system("chroot /mnt cat /tmp/machinereg.log");
    
    print "\nEtch\n";
    $self->installpkg('etch');
    
    system("chroot /mnt sh -c 'mount /proc; /var/etch/run_etch >/dev/null 2>&1; umount /proc'");
    sleep 5;
    print "\nCreating user homedirs\n";
    system("chroot /mnt /root/cron/create_homedirs --nowait");
}


sub install_gemstone {
    my $self = shift;
    my $cfg = $self->{cfg};
    unlink "/mnt/etc/securetty";
    
    $self->set_hostname;
    
    my $file;
    if($cfg->get('package_installer') eq 'yum') {
	$file = "/etc/yum.conf";
    } else {
	$file = "/etc/apt/sources.list";
    }
    
    system 'perl -pi -e "s!boothost(:80)?/!boothost:9999/!" /mnt' . $file;
    if (-e "/mnt/etc/redhat-release" && -e "/mnt$file") {
        symlink "/usr/bin/perl" => "/mnt/usr/local/bin/perl";
        $self->installpkg('seco-gemstone');
    }
    $self->installpkg('gemclient');
    unless ((-f "/mnt/usr/local/gemclient/bin/run") or
            (-f "/mnt/export/crawlspace/gemclient/bin/run")) {
	print "ERROR: Missing gemclient\n";
	system("sh");
    }
    
    print "\nGemstone pass 1\n";
    # the following returns true if it could HTTP GET gemstone-latest.tar.gz
    my $has_local_data = $self->download_gemclient_data;
    $self->run_gemclient($has_local_data);
    $self->check_redhat;
    $self->fix_resolv_conf();
    
    $self->install_ssh_keys;
    $self->create_etc_hosts;
    print "\nGemstone pass 2\n";
    $self->run_gemclient(1); # it does have local data after the first pass
    
    if(os() eq 'redhat') {
        my $prepsearch = `chroot /mnt rpm -q prepsearch`;
        if ($prepsearch !~ /not installed/) {
            System("chroot /mnt /bin/sh -c 'rpm -e prepsearch;yum -e 1 -d 1 -y install prepsearch'");
        }
    }
    
    $self->fix_resolv_conf();
    optional_shell();
    print("done.\n");
}

sub install_pci {
    
    return;
}

sub remount_root {
    print("Remounting / for read/write\n");
    run_local( "mount", "-o", "remount", "-o", "rw", "/" );
    unless ( -w "/" ) {
	crapout("Remounting / as read-write failed - / is not writable");
    }
}

sub fsck_newroot {
    my $self = shift;
    my $cfg = $self->{cfg};

    my $fs   = $cfg->get('def_fs');
    my $bootdevice;

    my $bootdisk = $cfg->get('bootdisk');
    if ($bootdisk) {
	my $root = $bootdisk;
	$root .= "p" if $bootdisk =~ /\d$/;
	$bootdevice = "/dev/$root" . "1";
    } else {
	$bootdevice = $cfg->get('bootdevice');
    }

    if($fs eq "ext2" or $fs eq "ext3") {
        -x "/sbin/fsck.ext3" or link "/sbin/fsck.ext2" => "/sbin/fsck.ext3"; # hack
	system("fsck.$fs -C -f -y $bootdevice");
	if ($?) {
	    print "WARNING: fsck returned an error! - ignoring\n";
	}
    }
}

sub unmount_newroot {
    print "INFO: Killing user processes:\n";
    open my $ps, "ps -ef|" or die "ps: $!";
    my @pids_to_kill;
    while (<$ps>) {
	next if /ps -ef/;
	next if /^UID/; # header
	my ($uid, $pid, $ppid, $c, $stime, $tty, $time, $cmd) = split;
	next if $pid == 1; # init
	next if $cmd =~ /^\[/; # OS command
	next if $cmd =~ m{^/pty}; # pty helper for ctrl+c
	next if $cmd =~ m{/bin/(sh|perl)};
	push @pids_to_kill, $pid;
	print "-> $_";
    }
    kill 15, @pids_to_kill;
    sleep 1;
    kill 9, @pids_to_kill;
    sleep 1;

    rename "/tmp/fstab.disk", "/mnt/etc/fstab" if(-f "/tmp/fstab.disk");

    system("chroot /mnt umount /proc");
    system("chroot /mnt umount /proc/sys/fs/binfmt_misc");
    system("umount -a 2>/dev/null >/dev/null");
    system("mount");
}

sub configure_nextboot {
    my $self = shift;

    print("Contacting web server to change next boot\n");

    my $hostname = $self->{cfg}->get('hostname');
    my $cmd = qq(echo "GET /jumpstart/normalboot.cgi?hostname=$hostname" | nc boothost 9999);
    run_local( "/bin/sh", "-c", $cmd );
}

1;
